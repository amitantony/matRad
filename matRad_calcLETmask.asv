function [LETmask,mLET] = matRad_calcLETmask(dij)
% Calculates logical matrix where LET is above (LETmask.Dirty) or below (LETmask.Clean) a certain threshold
%
% call
%   LETmask = matRad_calcLETmask(dij)
%
% input
%   dij:       matRad dij struct
%
% output
%   LETmask:   logical matrix for dirty dose
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %idx = dij.physicalDose{1}(:) ~= 0;
    [i,j,v] = find(dij.physicalDose{1});
    idx = sub2ind(size(dij.physicalDose{1}),i,j);
    
    mLET = dij.mLETDose{1}(idx)./v;
    mLET = sparse(i,j,mLET,dij.doseGrid.numOfVoxels,dij.totalNumOfBixels);
    
    mLET(idx) = nonzeros(dij.mLETDose{1})./nonzeros(dij.physicalDose{1});
    mLET = sparse(size(dij.mLETDose));
    mLET(idx) = dij.mLETDose{1}(idx)./dij.physicalDose{1}(idx);
    % mLET = full(dij.mLETDose{1}(idx))./full(dij.physicalDose{1}(idx));

   %mLET = full(dij.mLETDose{1}(:,:))./full(dij.physicalDose{1}(:,:));

    
   % only to calculate logical matrix for dirty dose
    if ~exist('dij','var') || isempty(dij)    
        dij = [];
        LETmask = [];
    else
        LETmask = mLET > dij.dirtyDoseThreshold;
    end

end